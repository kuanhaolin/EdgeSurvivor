# Story 5.2: 啟用私人聊天室

## Status

Draft

## Story

**As a** 使用者,
**I want** 在媒合申請被雙方確認後，自動開啟一個私人聊天室,
**so that** 我可以安全地與對方討論行程細節。

## Acceptance Criteria

### 聊天室自動建立

1. 當媒合申請狀態變為 'accepted' 時，系統自動為該媒合建立一個私人聊天室
2. 聊天室 ID 應與 match_id 關聯
3. 只有媒合的雙方（user_a 和 user_b）可以存取該聊天室
4. 聊天室建立後，雙方都應收到通知

### 聊天室列表

5. 使用者可以查看所有已媒合成功的聊天室列表
6. 聊天室列表應顯示：
   - 對方使用者的頭像和名稱
   - 最後一則訊息內容和時間
   - 未讀訊息數量（紅點提示）
7. 列表應按最後訊息時間降序排序（最新的在前）
8. 點擊聊天室卡片可進入該聊天室

### 聊天介面

9. 聊天介面應顯示對方使用者的頭像和名稱
10. 顯示聊天訊息歷史記錄
11. 每則訊息應顯示：
    - 發送者頭像（自己的訊息靠右，對方的靠左）
    - 訊息內容
    - 發送時間
12. 訊息輸入框應支援文字輸入（最多 1000 字）
13. 提供「發送」按鈕
14. 按下 Enter 鍵可快速發送訊息（Shift+Enter 換行）

### 即時通訊

15. 使用 Socket.IO 實現即時訊息傳遞
16. 當對方在線時，訊息應立即顯示在對方的聊天介面
17. 當對方離線時，訊息應儲存，對方上線後可查看
18. 發送訊息後應顯示「已送達」狀態
19. 對方讀取訊息後應顯示「已讀」狀態（可選實作）

### 訊息管理

20. 訊息應永久儲存在資料庫
21. 使用者可以查看完整的聊天歷史記錄
22. 支援訊息分頁載入（向上滾動載入更多歷史訊息）
23. 每次載入 30 則訊息

### 後端 API

24. **獲取聊天室列表** - GET /api/chat/rooms
    - Response (200): { "rooms": [{match_id, matched_user, last_message, unread_count}] }

25. **獲取聊天訊息** - GET /api/chat/rooms/{match_id}/messages?page=1&limit=30
    - Response (200): { "messages": [...], "has_more": true }

26. **標記訊息為已讀** - POST /api/chat/rooms/{match_id}/read
    - Response (200): { "message": "訊息已標記為已讀" }

### Socket.IO 事件

27. **連線事件** - 'connect': 建立 WebSocket 連線
28. **加入聊天室** - 'join_room': 加入特定媒合的聊天室
29. **發送訊息** - 'send_message': 發送訊息到聊天室
30. **接收訊息** - 'receive_message': 接收來自對方的訊息
31. **已讀回執** - 'message_read': 訊息已讀通知
32. **離線事件** - 'disconnect': 斷開 WebSocket 連線

### 效能與體驗

33. 訊息發送回應時間需低於 200ms
34. 聊天室列表載入時間需低於 500ms
35. 使用虛擬滾動優化大量訊息的渲染效能
36. 頁面載入時顯示骨架屏（Skeleton）
37. 發送訊息時顯示載入狀態
38. 訊息發送失敗時顯示錯誤提示並提供重試機制

### 安全性

39. 所有 API 和 Socket.IO 事件需要 JWT 認證
40. 驗證使用者是否為該媒合的參與者（user_a 或 user_b）
41. 防止跨聊天室訊息洩漏
42. 輸入驗證：訊息內容不可為空，最多 1000 字

### UI/UX

43. 響應式設計，適配桌面、平板、手機
44. 自動滾動到最新訊息
45. 發送訊息後清空輸入框
46. 顯示對方「正在輸入...」狀態（可選實作）
47. 支援表情符號（可選實作）



## Tasks

### Phase 1: 後端 API 開發（基於現有 Socket.IO）

**[Task 1.1] 建立聊天室列表 API**
- **檔案**: ackend/blueprints/chat.py
- 建立 Blueprint (若不存在)
- 實作 GET /api/chat/rooms 端點
- 查詢所有 status='accepted' 的媒合
- 關聯查詢最後一則訊息
- 計算未讀訊息數量
- 回傳格式化的聊天室列表

**[Task 1.2] 建立訊息查詢 API**
- **檔案**: ackend/blueprints/chat.py
- 實作 GET /api/chat/rooms/{match_id}/messages 端點
- 驗證使用者權限（是否為該媒合的參與者）
- 支援分頁查詢（page, limit 參數）
- 按時間降序排序
- 回傳訊息列表和是否還有更多訊息

**[Task 1.3] 建立訊息已讀標記 API**
- **檔案**: ackend/blueprints/chat.py
- 實作 POST /api/chat/rooms/{match_id}/read 端點
- 更新 chat_messages.is_read = True
- 只標記對方發送的訊息
- 透過 Socket.IO 發送已讀通知給對方

**[Task 1.4] 擴展 ChatMessage Model**
- **檔案**: ackend/models/chat_message.py
- 新增欄位：is_read (Boolean, default=False)
- 新增 	o_dict() 方法，方便序列化

**[Task 1.5] 增強 Socket.IO 事件處理**
- **檔案**: ackend/socketio_events.py
- 實作 send_message 事件處理器
  - 驗證訊息內容（非空、長度限制）
  - 儲存訊息到資料庫
  - 廣播到聊天室內的其他使用者
- 實作 message_read 事件處理器
  - 更新訊息 is_read 狀態
  - 通知發送者
- 實作 join_room 事件處理器（若尚未完整）
  - 驗證使用者是否為媒合參與者
  - 加入 Socket.IO room (room_id = f"match_{match_id}")

### Phase 2: 前端聊天室列表頁

**[Task 2.1] 建立聊天室列表組件**
- **檔案**: rontend/src/views/ChatRooms.vue
- 建立聊天室列表頁面
- 顯示所有已媒合成功的聊天室
- 每個聊天室卡片包含：
  - 對方頭像（使用 Element Plus Avatar）
  - 對方名稱
  - 最後訊息內容（截斷至 50 字）
  - 最後訊息時間（格式化為相對時間）
  - 未讀訊息數量徽章
- 點擊卡片跳轉到聊天室詳情頁

**[Task 2.2] 實作聊天室列表 API 整合**
- **檔案**: rontend/src/api/chat.js
- 建立 getChatRooms() 方法
- 使用 axios 呼叫 GET /api/chat/rooms
- 處理 loading 和 error 狀態

**[Task 2.3] 聊天室列表排序與篩選**
- **檔案**: rontend/src/views/ChatRooms.vue
- 按最後訊息時間降序排序
- 未讀訊息的聊天室優先顯示（可選）
- 空狀態顯示：「您還沒有任何聊天室」

### Phase 3: 前端聊天室詳情頁

**[Task 3.1] 建立聊天室詳情組件**
- **檔案**: rontend/src/views/ChatRoom.vue
- 建立聊天室詳情頁面（基於 match_id）
- 頂部顯示對方資訊（頭像、名稱）
- 中間顯示訊息列表（虛擬滾動）
- 底部顯示訊息輸入框和發送按鈕

**[Task 3.2] 實作訊息列表顯示**
- **檔案**: rontend/src/views/ChatRoom.vue
- 載入歷史訊息（初始載入 30 則）
- 區分自己和對方的訊息：
  - 自己的訊息：靠右、藍色背景
  - 對方的訊息：靠左、灰色背景
- 顯示發送時間（使用 dayjs 格式化）
- 顯示頭像

**[Task 3.3] 實作訊息發送功能**
- **檔案**: rontend/src/views/ChatRoom.vue
- 訊息輸入框（Element Plus Input + Textarea）
- 發送按鈕（Element Plus Button）
- 按 Enter 發送（Shift+Enter 換行）
- 發送前驗證：
  - 訊息不可為空
  - 訊息長度不可超過 1000 字
- 發送後清空輸入框
- 顯示發送狀態（loading、成功、失敗）

**[Task 3.4] 實作訊息分頁載入**
- **檔案**: rontend/src/views/ChatRoom.vue
- 向上滾動時載入更多歷史訊息
- 使用 IntersectionObserver 或監聽 scroll 事件
- 載入時顯示 loading 狀態
- 沒有更多訊息時停止載入

**[Task 3.5] 實作自動滾動到最新訊息**
- **檔案**: rontend/src/views/ChatRoom.vue
- 初始載入時滾動到最新訊息
- 收到新訊息時自動滾動（僅當使用者在底部時）
- 使用 scrollIntoView() 或 scrollTop

### Phase 4: Socket.IO 即時通訊整合

**[Task 4.1] 建立 Socket.IO 連線管理**
- **檔案**: rontend/src/utils/socket.js
- 建立 Socket.IO 客戶端實例
- 連線時附加 JWT token
- 實作連線狀態管理（connected, disconnected）
- 實作重連機制

**[Task 4.2] 實作加入聊天室**
- **檔案**: rontend/src/views/ChatRoom.vue
- 進入聊天室時發送 join_room 事件
- 傳遞 match_id
- 離開聊天室時發送 leave_room 事件

**[Task 4.3] 實作即時訊息發送**
- **檔案**: rontend/src/views/ChatRoom.vue
- 發送訊息時使用 Socket.IO emit send_message 事件
- 傳遞 match_id 和訊息內容
- 樂觀更新：立即顯示訊息（發送中狀態）
- 收到確認後更新為已送達狀態

**[Task 4.4] 實作即時訊息接收**
- **檔案**: rontend/src/views/ChatRoom.vue
- 監聽 eceive_message 事件
- 收到訊息後加入到訊息列表
- 自動滾動到最新訊息
- 發送已讀通知（若聊天室是當前活躍頁面）

**[Task 4.5] 實作已讀回執**
- **檔案**: rontend/src/views/ChatRoom.vue
- 監聽 message_read 事件
- 更新訊息狀態為「已讀」
- 顯示已讀標記（雙勾勾或文字提示）

### Phase 5: 狀態管理與資料持久化

**[Task 5.1] 建立聊天 Pinia Store**
- **檔案**: rontend/src/stores/chat.js
- 管理聊天室列表
- 管理當前聊天室的訊息列表
- 管理 Socket.IO 連線狀態
- 管理未讀訊息數量

**[Task 5.2] 實作聊天室快取機制**
- **檔案**: rontend/src/stores/chat.js
- 快取已載入的訊息，避免重複請求
- 離開聊天室時保留快取（可設定過期時間）
- 重新進入時優先使用快取

### Phase 6: UI/UX 優化

**[Task 6.1] 實作骨架屏（Skeleton）**
- **檔案**: rontend/src/views/ChatRooms.vue, ChatRoom.vue
- 載入聊天室列表時顯示 Skeleton
- 載入訊息時顯示 Skeleton
- 使用 Element Plus Skeleton 組件

**[Task 6.2] 實作響應式設計**
- **檔案**: CSS 調整
- 桌面版：聊天室列表在左側，聊天室詳情在右側（Split View）
- 平板/手機：使用全螢幕切換（Chat List  Chat Room）
- 使用 CSS Media Queries

**[Task 6.3] 實作錯誤處理與重試機制**
- **檔案**: 所有相關組件
- API 請求失敗時顯示錯誤訊息（Element Plus Message）
- Socket.IO 斷線時顯示重連提示
- 訊息發送失敗時提供重試按鈕

**[Task 6.4] 實作「正在輸入...」狀態（可選）**
- **檔案**: rontend/src/views/ChatRoom.vue, ackend/socketio_events.py
- 監聽輸入框 input 事件
- 發送 	yping Socket.IO 事件
- 對方顯示「對方正在輸入...」提示
- 使用防抖（debounce）避免頻繁發送

### Phase 7: 測試與驗證

**[Task 7.1] 後端 API 單元測試**
- **檔案**: ackend/tests/test_chat.py
- 測試獲取聊天室列表 API
- 測試獲取訊息 API
- 測試標記已讀 API
- 測試權限驗證（非媒合參與者無法存取）

**[Task 7.2] Socket.IO 整合測試**
- **檔案**: ackend/tests/test_socketio.py
- 測試連線與認證
- 測試加入聊天室
- 測試發送訊息
- 測試即時訊息廣播
- 測試已讀回執

**[Task 7.3] 前端組件測試**
- **檔案**: rontend/tests/ChatRooms.spec.js, ChatRoom.spec.js
- 測試聊天室列表渲染
- 測試訊息列表渲染
- 測試訊息發送功能
- 測試分頁載入

**[Task 7.4] E2E 測試**
- **檔案**: 新增 E2E 測試檔案
- 模擬兩個使用者互相發送訊息
- 驗證即時通訊功能
- 驗證已讀回執功能

### Phase 8: 部署與監控

**[Task 8.1] 環境變數配置**
- **檔案**: .env, docker-compose.yml
- 配置 Socket.IO CORS 設定
- 配置 WebSocket 傳輸協定（polling + websocket）

**[Task 8.2] 效能監控**
- 監控 Socket.IO 連線數量
- 監控訊息延遲時間
- 記錄訊息發送失敗率

**[Task 8.3] 錯誤日誌**
- **檔案**: ackend/socketio_events.py
- 記錄 Socket.IO 連線錯誤
- 記錄訊息發送失敗錯誤
- 使用 Python logging 模組


