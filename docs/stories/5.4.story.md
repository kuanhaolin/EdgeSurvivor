# Story 5.4: 修改費用記錄

## Status
**Deferred（暫緩）**

**暫緩原因**：
- ⚠️ **賴帳風險**：允許修改金額和分攤對象可能導致爭議和信任問題
- ⚠️ **缺少保護機制**：AC 3（修改通知）和 AC 4（修改歷史）標記為"未來"，目前不實作
- ⚠️ **業務決策**：在實作完整的修改歷史記錄和通知機制前，暫緩此功能

**前置需求**（需先完成）：
1. 實作修改歷史記錄表（audit log）
2. 實作即時通知機制（通知所有分攤參與者）
3. 可選：增加修改時間限制或需要確認機制

**替代方案**（當前可用）：
- 用戶可以**刪除後重建**費用記錄
- 刪除權限已有控制（只有代墊人或活動創建者）

## Story

**As a** 費用建立者,
**I want** 修正已建立的費用記錄資訊,
**so that** 我發現之前記錄的費用金額有誤，需要更新

## Acceptance Criteria

1. 只有費用建立者可以編輯該費用
2. 可以修改描述、金額、分帳類型、分帳對象
3. ⚠️ **修改後所有分帳人員應收到通知**（**必要前置條件**）
4. ⚠️ **修改歷史應被記錄**（**必要前置條件**）

## Tasks / Subtasks

### Phase 1: 後端費用更新 API (AC: 1, 2)

- [ ] **Task 1.1**: 實作費用更新 API 端點 (AC: 1, 2)
  - [ ] 在 `backend/blueprints/expenses.py` 創建新端點 `PUT /api/expenses/<expense_id>`
  - [ ] 端點使用 `@jwt_required()` 裝飾器驗證身分
  - [ ] 驗證當前用戶必須是費用的 payer_id（只有代墊人可以修改）
  - [ ] 驗證費用記錄存在，否則返回 404
  - [ ] 允許更新以下欄位：
    - `description` (費用描述)
    - `amount` (金額)
    - `category` (類別)
    - `expense_date` (費用日期)
    - `split_type` (分攤類型)
    - `split_participants` (分攤參與者，當 split_type='selected')
    - `borrower_id` (借款人，當 split_type='borrow')
  - [ ] 不允許更新：`expense_id`, `activity_id`, `payer_id`, `created_at`
  - [ ] 回應更新後的費用記錄（使用 `to_dict(include_details=True)`）

- [ ] **Task 1.2**: 實作輸入驗證邏輯 (AC: 2)
  - [ ] 複用與 Story 5.1 相同的驗證規則：
    - `description`: 不能為空字串
    - `amount`: 必須 > 0
    - `category`: 必須在 ['transport', 'accommodation', 'food', 'ticket', 'other'] 中
    - `split_type`: 必須在 ['all', 'selected', 'borrow'] 中
  - [ ] 驗證 `split_type='selected'` 時：
    - `split_participants` 不能為空
    - `split_participants` 必須包含 `payer_id`
  - [ ] 驗證 `split_type='borrow'` 時：
    - 必須提供 `borrower_id`
    - `borrower_id` 對應的用戶必須存在
  - [ ] 驗證 `expense_date` 格式（若提供）為 ISO 8601 (YYYY-MM-DD)
  - [ ] 任何驗證失敗返回 400 錯誤和具體錯誤訊息

- [ ] **Task 1.3**: 處理分攤類型轉換邏輯 (AC: 2)
  - [ ] 當 split_type 從 'selected' 改為 'all' 時：
    - 清空 `split_participants` 或設為所有活動參與者
    - 清空 `borrower_id`
  - [ ] 當 split_type 從 'all' 改為 'selected' 時：
    - 驗證必須提供 `split_participants`
  - [ ] 當 split_type 改為 'borrow' 時：
    - 驗證必須提供 `borrower_id`
    - 設定 `is_split=False`
    - 清空 `split_participants`
  - [ ] 當從 'borrow' 改為其他類型時：
    - 清空 `borrower_id`
    - 設定 `is_split=True`

- [ ] **Task 1.4**: 測試費用更新 API (AC: 1, 2)
  - [ ] 編寫測試：成功更新費用描述
  - [ ] 編寫測試：成功更新費用金額
  - [ ] 編寫測試：成功更新費用類別
  - [ ] 編寫測試：成功更新費用日期
  - [ ] 編寫測試：成功更新分攤類型（all → selected → borrow）
  - [ ] 編寫測試：非代墊人無法更新費用（403）
  - [ ] 編寫測試：未登入用戶無法更新（401）
  - [ ] 編寫測試：費用不存在返回 404
  - [ ] 編寫測試：無效金額返回 400（金額 <= 0）
  - [ ] 編寫測試：無效類別返回 400
  - [ ] 編寫測試：split_type='selected' 但未提供參與者返回 400
  - [ ] 編寫測試：split_type='borrow' 但未提供借款人返回 400
  - [ ] 編寫測試：無效日期格式返回 400

### Phase 2: 前端費用編輯功能 (AC: 1, 2)

- [ ] **Task 2.1**: 新增編輯費用對話框 (AC: 1, 2)
  - [ ] 在 `frontend/src/components/ExpenseManager.vue` 新增編輯模式
  - [ ] 複用現有的費用表單（`expenseForm`）用於編輯
  - [ ] 新增 `isEditing` 狀態變數和 `editingExpenseId` 變數
  - [ ] 新增「編輯」按鈕到費用列表的每一行（使用 el-button，僅對 payer 顯示）
  - [ ] 點擊編輯按鈕時：
    - 設定 `isEditing=true`
    - 記錄 `editingExpenseId`
    - 預填表單欄位（description, amount, category, expense_date, split_type 等）
    - 開啟費用表單對話框
  - [ ] 對話框標題依模式顯示：「新增費用」 vs 「編輯費用」

- [ ] **Task 2.2**: 實作費用更新 API 呼叫 (AC: 2)
  - [ ] 修改 `submitExpense` 方法：
    - 檢查 `isEditing` 狀態
    - 若 `isEditing=true`，呼叫 `PUT /api/expenses/<editingExpenseId>`
    - 若 `isEditing=false`，呼叫原有的 `POST` 端點
  - [ ] 更新成功後：
    - 顯示成功訊息：「費用已更新」
    - 重新載入費用列表
    - 關閉對話框
    - 重置 `isEditing` 和 `editingExpenseId`
  - [ ] 處理錯誤情況：
    - 403: 顯示「只有代墊人可以編輯此費用」
    - 404: 顯示「費用記錄不存在」
    - 400: 顯示後端返回的具體錯誤訊息

- [ ] **Task 2.3**: 實作表單預填與驗證 (AC: 2)
  - [ ] 創建 `loadExpenseForEdit(expense)` 方法：
    - 從費用物件填充 `expenseForm` 所有欄位
    - 處理 `split_participants` JSON 解析
    - 設定 `expense_date` 為 Date 物件
  - [ ] 複用現有的表單驗證邏輯（from Story 5.1）：
    - `validateDescription()`
    - `validateAmount()`
    - `validateCategory()`
    - `validateSplitType()`
    - `validateSplitParticipants()`
    - `validateBorrowerId()`
  - [ ] 取消編輯時清空表單並重置 `isEditing` 狀態

- [ ] **Task 2.4**: 測試費用編輯功能 (AC: 1, 2)
  - [ ] 編寫組件測試：編輯按鈕僅對代墊人顯示
  - [ ] 編寫組件測試：點擊編輯按鈕預填表單
  - [ ] 編寫組件測試：成功更新費用並重新載入列表
  - [ ] 編寫組件測試：驗證錯誤處理（400, 403, 404）
  - [ ] 編寫組件測試：取消編輯重置表單狀態
  - [ ] 編寫組件測試：分攤類型切換時欄位正確聯動

### Phase 3: 整合與端到端測試 (AC: 1, 2)

- [ ] **Task 3.1**: 端到端測試
  - [ ] 測試完整流程：登入 → 查看費用 → 編輯費用 → 驗證更新
  - [ ] 測試權限：非代墊人看不到編輯按鈕
  - [ ] 測試分攤類型切換：all → selected → borrow
  - [ ] 測試錯誤處理：無效輸入、權限不足

- [ ] **Task 3.2**: 文檔與程式碼審查
  - [ ] 確認 API 端點符合 RESTful 規範
  - [ ] 確認錯誤訊息清晰易懂
  - [ ] 確認程式碼風格一致性（遵循專案標準）
  - [ ] 更新 API 文檔（如有）

## Dev Notes

### 架構與技術背景

**專案概覽** [Source: docs/brownfield-architecture.md#簡介]:
- EdgeSurvivor 是旅伴媒合與活動管理平台
- 三層式 Web 應用：Vue 3 前端 + Flask 後端 + MariaDB 資料庫
- RESTful API 架構，使用 JWT 認證

**費用管理現狀** [Source: docs/stories/5.1.story.md, 5.2.story.md, 5.3.story.md]:
- Story 5.1 實作了費用創建功能
- Story 5.2 實作了費用列表查看功能
- Story 5.3 實作了個人費用統計功能
- 現有端點：
  - `GET /api/activities/<activity_id>/expenses` - 查看活動費用清單
  - `POST /api/activities/<activity_id>/expenses` - 創建費用記錄
  - `DELETE /api/expenses/<expense_id>` - 刪除費用記錄
  - `GET /api/expenses/user/<user_id>/stats` - 個人費用統計
  - `GET /api/activities/<activity_id>/expenses/settlement` - 活動結算
- **本故事需新增**：`PUT /api/expenses/<expense_id>` - 更新費用記錄

### 前一個故事的重要洞察

**Story 5.3 實作經驗** [Source: docs/stories/5.3.story.md#Dev Agent Record]:
- 後端 API 已完成並通過測試
- 前端實作被業務決策延後（ExpenseManager 組件已提供足夠的費用管理功能）
- 分攤金額計算邏輯已在 Story 5.3 中完整實作並測試
- 需注意三種分攤類型的處理：'all', 'selected', 'borrow'

### 資料模型

**Expense 模型欄位** [Source: backend/models/expense.py]:
```python
class Expense(db.Model):
    expense_id = db.Column(db.Integer, primary_key=True)
    activity_id = db.Column(db.Integer, db.ForeignKey('activities.activity_id'))
    payer_id = db.Column(db.Integer, db.ForeignKey('users.user_id'))  # 代墊人/付款者
    amount = db.Column(Numeric(10, 2), nullable=False)
    description = db.Column(db.Text)
    expense_date = db.Column(db.Date, default=datetime.utcnow)
    category = db.Column(db.String(50))  # 'transport', 'accommodation', 'food', 'ticket', 'other'
    
    # 分攤相關欄位
    split_type = db.Column(db.String(20), default='all')  # 'all', 'selected', 'borrow'
    is_split = db.Column(db.Boolean, default=True)
    split_method = db.Column(db.String(20), default='equal')
    split_participants = db.Column(db.Text)  # JSON 格式
    borrower_id = db.Column(db.Integer, db.ForeignKey('users.user_id'), nullable=True)
    
    # 向後兼容
    participants = db.Column(db.Text)  # 舊欄位
    
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    # 關聯
    activity = db.relationship('Activity', backref='expenses')
    payer = db.relationship('User', foreign_keys=[payer_id], backref='paid_expenses')
    borrower = db.relationship('User', foreign_keys=[borrower_id], backref='borrowed_expenses')
```

**可更新的欄位**：
- description, amount, category, expense_date
- split_type, split_participants, borrower_id

**不可更新的欄位**：
- expense_id, activity_id, payer_id, created_at

### API 規格設計

**新端點資訊**:
```
PUT /api/expenses/<expense_id>
```

**認證**: 需要 JWT token (`@jwt_required()`)

**權限**: 只有費用的 payer_id 可以更新（代墊人/建立者）

**請求體** (JSON):
```json
{
  "description": "午餐費用（更新）",
  "amount": 600.00,
  "category": "food",
  "expense_date": "2025-12-16",
  "split_type": "selected",
  "split_participants": [123, 456, 789],  // split_type='selected' 時必填
  "borrower_id": 456                      // split_type='borrow' 時必填
}
```

**欄位說明**：
- 所有欄位都是可選的（僅更新提供的欄位）
- 但若提供，必須符合驗證規則

**回應格式** (200 OK):
```json
{
  "message": "費用記錄已更新",
  "expense": {
    "expense_id": 1,
    "activity_id": 10,
    "payer_id": 123,
    "amount": 600.00,
    "description": "午餐費用（更新）",
    "category": "food",
    "split_type": "selected",
    "split_participants": "[123, 456, 789]",
    "borrower_id": null,
    "expense_date": "2025-12-16",
    "created_at": "2025-12-15T10:00:00",
    "payer": {
      "user_id": 123,
      "name": "張三",
      "avatar": "https://..."
    }
  }
}
```

**錯誤回應**:
- 400: 無效的輸入（金額 <= 0、無效類別、缺少必填欄位等）
- 401: 未登入
- 403: 只有代墊人可以編輯此費用
- 404: 費用記錄不存在
- 500: 伺服器錯誤

### 輸入驗證規則

**必須與 Story 5.1 保持一致** [Source: backend/blueprints/expenses.py#create_expense]:

1. **description**: 不能為空字串
2. **amount**: 必須 > 0
3. **category**: 必須在 ['transport', 'accommodation', 'food', 'ticket', 'other'] 中
4. **split_type**: 必須在 ['all', 'selected', 'borrow'] 中
5. **split_type='selected'** 時:
   - `split_participants` 不能為空
   - `split_participants` 必須包含 `payer_id`
6. **split_type='borrow'** 時:
   - 必須提供 `borrower_id`
   - `borrower_id` 對應的用戶必須存在
7. **expense_date**: ISO 8601 格式 (YYYY-MM-DD)

### 檔案位置與專案結構

**後端檔案** [Source: docs/brownfield-architecture.md#Repository 結構現狀]:
- Blueprint: `backend/blueprints/expenses.py` - 新增 PUT 端點到此檔案
- Model: `backend/models/expense.py` - Expense 模型定義
- Test: `backend/test/TC_5_4_*.py` - 新增測試檔案

**前端檔案** [Source: docs/brownfield-architecture.md#Repository 結構現狀]:
- Component: `frontend/src/components/ExpenseManager.vue` - 修改此組件新增編輯功能
- Validation: `frontend/src/utils/expenseValidation.js` - 複用現有驗證邏輯
- Test: `frontend/tests/components/ExpenseManager.spec.js` - 新增編輯功能測試

### 重要實作注意事項

**權限控制** [Source: backend/blueprints/expenses.py#delete_expense]:
```python
# 參考現有的刪除端點權限檢查模式
current_user_id = int(get_jwt_identity())
expense = Expense.query.get(expense_id)

if not expense:
    return jsonify({'error': '找不到費用記錄'}), 404

# 只有付款者可以編輯
if expense.payer_id != current_user_id:
    return jsonify({'error': '只有代墊人可以編輯此費用'}), 403
```

**分攤類型轉換邏輯**：
- 當改變 split_type 時，需要清理或設定相關欄位
- 'all': 清空 split_participants 和 borrower_id
- 'selected': 需要 split_participants，清空 borrower_id
- 'borrow': 需要 borrower_id，清空 split_participants，設定 is_split=False

**JSON 處理** [Source: backend/blueprints/expenses.py#create_expense]:
```python
# split_participants 需要序列化為 JSON
import json
expense.split_participants = json.dumps(split_participants) if split_participants else None
```

**前端表單預填** [Source: frontend/src/components/ExpenseManager.vue]:
- 需要深拷貝費用物件避免直接修改原始資料
- `split_participants` 需要從 JSON 字串解析為陣列
- `expense_date` 需要轉換為 Date 物件供 el-date-picker 使用

### 測試策略

**後端測試位置** [Source: docs/brownfield-architecture.md#測試策略]:
- 測試檔案命名：`backend/test/TC_5_4_update_expense.py`
- 使用 pytest 框架
- 使用 SQLite 記憶體資料庫隔離測試

**測試框架** [Source: backend/test/conftest.py]:
```python
@pytest.fixture
def test_app():
    """創建測試用 Flask app"""
    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:'
    app.config['TESTING'] = True
    with app.app_context():
        db.create_all()
        yield app
        db.session.remove()
        db.drop_all()
```

**前端測試** [Source: docs/brownfield-architecture.md#測試策略]:
- 使用 Vitest 和 Vue Test Utils
- 測試檔案位置：`frontend/tests/components/ExpenseManager.spec.js`
- Mock Axios 呼叫避免實際 API 請求

### 錯誤處理模式

**後端錯誤處理** [Source: backend/blueprints/expenses.py]:
```python
try:
    # 業務邏輯
    db.session.commit()
    return jsonify({...}), 200
except Exception as e:
    db.session.rollback()
    print(f"更新費用失敗: {str(e)}")  # 記錄詳細錯誤
    return jsonify({'error': str(e)}), 500
```

**前端錯誤處理** [Source: frontend/src/components/ExpenseManager.vue]:
```javascript
try {
  const response = await axios.put(`/api/expenses/${expenseId}`, data)
  ElMessage.success('費用已更新')
  // 重新載入列表
} catch (error) {
  if (error.response) {
    ElMessage.error(error.response.data.error || '更新失敗')
  } else {
    ElMessage.error('網路錯誤')
  }
}
```

### 與現有功能的整合

**ExpenseManager 組件現狀** [Source: frontend/src/components/ExpenseManager.vue]:
- 已實作費用列表顯示
- 已實作新增費用對話框和表單
- 已實作費用刪除功能
- 已有完整的表單驗證邏輯
- **本故事需新增**：編輯模式和 PUT API 呼叫

**複用現有程式碼**：
- 複用 `expenseForm` 響應式物件
- 複用表單驗證方法（validateDescription, validateAmount 等）
- 複用對話框 UI（依 `isEditing` 狀態切換標題和提交邏輯）

## Testing

### 測試標準 [Source: docs/brownfield-architecture.md#測試策略]

**後端測試要求**：
- 測試檔案位置：`backend/test/`
- 命名規範：`TC_5_4_*.py` (TC = Test Case)
- 使用 pytest 框架
- 每個測試函數必須以 `test_` 開頭
- 使用記憶體資料庫（SQLite）隔離測試
- 測試覆蓋率目標：> 80%

**測試類型**：
1. **功能測試**：驗證 API 端點行為正確
2. **驗證測試**：驗證輸入驗證規則
3. **權限測試**：驗證只有代墊人可以編輯
4. **錯誤測試**：驗證錯誤處理和回應

**前端測試要求**：
- 測試檔案位置：`frontend/tests/components/`
- 使用 Vitest 和 Vue Test Utils
- Mock API 呼叫避免實際網路請求
- 測試用戶互動（點擊、輸入、表單提交）

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-16 | 1.0 | Initial story draft created | Bob (Scrum Master) |
| 2025-12-16 | 1.1 | 狀態更新為 Deferred - 因賴帳風險和缺少必要保護機制（修改歷史、通知） | Product Owner |

## Dev Agent Record

*此區段由開發代理在實作期間填寫*

### Agent Model Used

*待填寫*

### Debug Log References

*待填寫*

### Completion Notes List

*待填寫*

### File List

*待填寫*

## QA Results

*此區段由 QA 代理填寫*
