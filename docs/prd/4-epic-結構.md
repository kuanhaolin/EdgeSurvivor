# 4. Epic 結構

## Epic 1: 用戶認證與授權系統 (User Authentication & Authorization)

### 用戶故事

#### Story 1.1: 用戶註冊
**身份**：新用戶  
**目的**：建立個人帳號以使用平台服務  
**場景**：我是新用戶，想要註冊一個帳號開始使用 EdgeSurvivor 平台

**驗收標準**：
- 可以透過 email 和密碼註冊
- Email 格式驗證（必須是有效的 email 格式）
- 密碼強度驗證（至少 8 字元，包含英文和數字）
- 密碼自動進行 Werkzeug 雜湊加密儲存
- 不允許重複的 email 註冊
- 註冊成功後自動登入並返回 JWT token
- 顯示註冊成功訊息

**整合驗證點**：
- 系統應呼叫 `POST /api/auth/register` 端點
- 請求 payload 應包含：email, password, name（選填）
- 後端應檢查 email 唯一性（查詢 users 表）
- 密碼應使用 `werkzeug.security.generate_password_hash()` 加密
- 成功後返回 access_token 和 refresh_token（Flask-JWT-Extended）
- 前端應將 token 儲存到 localStorage 或 sessionStorage

#### Story 1.2: 用戶登入
**身份**：已註冊用戶  
**目的**：使用 email 和密碼登入帳號  
**場景**：我是已註冊用戶，想要登入以存取我的個人資料和活動

**驗收標準**：
- 可以輸入 email 和密碼登入
- 驗證 email 和密碼是否正確
- 登入成功後返回 JWT token（access 和 refresh）
- 登入失敗顯示錯誤訊息（如：帳號或密碼錯誤）
- 支援「記住我」功能（選填）
- Token 過期時自動導向登入頁

**整合驗證點**：
- 系統應呼叫 `POST /api/auth/login` 端點
- 後端應使用 `werkzeug.security.check_password_hash()` 驗證密碼
- 成功後使用 `create_access_token()` 和 `create_refresh_token()` 生成 JWT
- 前端應在後續 API 請求的 Authorization header 中帶上 Bearer token
- 密碼錯誤應返回 401 Unauthorized 狀態碼

#### Story 1.3: JWT Token 刷新
**身份**：已登入用戶  
**目的**：在 access token 過期時自動刷新以保持登入狀態  
**場景**：我正在使用平台，access token 即將過期，系統應自動刷新而不需要我重新登入

**驗收標準**：
- Access token 過期時可使用 refresh token 取得新的 access token
- 刷新過程對用戶透明（不中斷操作）
- Refresh token 也有過期時間（較長）
- Refresh token 過期後需重新登入
- 每次刷新應返回新的 access token

**整合驗證點**：
- 系統應呼叫 `POST /api/auth/refresh` 端點
- 請求 header 應包含 `Authorization: Bearer <refresh_token>`
- 端點應使用 `@jwt_required(refresh=True)` 裝飾器
- 後端應使用 `create_access_token()` 生成新 token
- 前端應實作攔截器（Axios interceptor）自動處理 401 錯誤並刷新 token

#### Story 1.4: 啟用雙因素認證 (2FA)
**身份**：註重安全的用戶  
**目的**：啟用 2FA 以增強帳號安全性  
**場景**：我想要為我的帳號增加額外的安全保護，啟用雙因素認證

**驗收標準**：
- 可以在帳號設定中啟用 2FA
- 系統生成 TOTP secret 並顯示 QR code
- 用戶使用 Google Authenticator 等應用掃描 QR code
- 輸入 6 位數驗證碼確認啟用
- 啟用後登入時需要輸入 2FA 驗證碼
- 可以生成備用碼（未來功能）

**整合驗證點**：
- 系統應呼叫 `POST /api/auth/2fa/enable` 端點
- 後端使用 `pyotp.random_base32()` 生成 secret
- Secret 儲存到 User 模型的 `totp_secret` 欄位
- QR code 使用 `pyotp.totp.TOTP(secret).provisioning_uri()` 生成
- 前端顯示 QR code 供用戶掃描

#### Story 1.5: 使用 2FA 登入
**身份**：已啟用 2FA 的用戶  
**目的**：使用 2FA 驗證碼完成安全登入  
**場景**：我已啟用 2FA，登入時需要輸入驗證碼

**驗收標準**：
- 輸入 email 和密碼後，顯示 2FA 驗證碼輸入框
- 輸入 6 位數 TOTP 驗證碼
- 驗證碼正確後完成登入
- 驗證碼錯誤顯示錯誤訊息
- 驗證碼有時間限制（30 秒輪換）
- 提供「信任此裝置」選項（未來功能）

**整合驗證點**：
- 系統應呼叫 `POST /api/auth/login` 端點，包含 totp_code 參數
- 後端使用 `pyotp.TOTP(user.totp_secret).verify(code)` 驗證
- User 模型的 `is_2fa_enabled` 欄位應為 True
- 驗證失敗返回 401 並附帶錯誤訊息

#### Story 1.6: 編輯用戶個人資料
**身份**：已登入用戶  
**目的**：更新個人資料和偏好設定  
**場景**：我想更新我的個人資訊，讓其他用戶更了解我

**驗收標準**：
- 可以編輯姓名、地點、簡介、性別、年齡
- 可以新增或編輯興趣標籤（JSON 格式儲存）
- 可以設定隱私等級（public/partial/hidden）
- 可以設定社交隱私（public/friends_only）
- 可以上傳或更換頭像
- 修改後即時儲存並顯示更新成功訊息

**整合驗證點**：
- 系統應呼叫 `PUT /api/users/<user_id>` 端點
- 端點應使用 `@jwt_required()` 驗證身分
- 後端應驗證當前用戶只能編輯自己的資料（user_id 匹配）
- 興趣標籤應以 JSON 格式儲存到 `interests` 欄位
- 頭像 URL 儲存到 `avatar_url` 欄位

#### Story 1.7: 查看用戶個人資料
**身份**：所有用戶  
**目的**：查看其他用戶的公開資料以了解旅伴背景  
**場景**：我想查看某位用戶的個人資料，確認是否適合一起旅行

**驗收標準**：
- 可以查看用戶的公開資料（依照隱私設定）
- 顯示用戶姓名、頭像、地點、簡介、興趣
- 顯示用戶的評價統計（rating_count, average_rating）
- 隱私設定為 hidden 的用戶資料不可見
- 隱私設定為 partial 的用戶部分資料不可見（如年齡、性別）
- 顯示用戶參與過的活動數量

**整合驗證點**：
- 系統應呼叫 `GET /api/users/<user_id>` 端點
- 後端應根據 `privacy_level` 欄位過濾回應資料
- 前端應優雅處理不同隱私等級的顯示

---

## Epic 2: 活動管理系統 (Activity Management)

### 用戶故事

#### Story 2.1: 創建活動
**身份**：已登入用戶  
**目的**：發布一個新的旅遊或活動邀請  
**場景**：我計劃了一趟旅行，想找志同道合的旅伴一起參加

**驗收標準**：
- 可以輸入活動標題和詳細描述
- 可以選擇活動類別（hiking, camping, travel, sports 等）
- 可以設定活動日期範圍（start_date, end_date）和時間（start_time, end_time）
- 可以設定活動地點和集合點
- 可以設定最大參與人數（max_participants）
- 可以設定活動費用和難度等級（easy/medium/hard）
- 可以設定參與者條件（性別偏好、年齡範圍）
- 可以上傳封面圖和活動圖片
- 創建成功後顯示活動詳情頁

**整合驗證點**：
- 系統應呼叫 `POST /api/activities` 端點
- 端點應使用 `@jwt_required()` 驗證身分
- 創建者自動設為 `creator_id`（從 JWT 取得）
- 活動狀態預設為 `active`
- 封面圖先透過 `POST /api/upload` 上傳取得 URL，再儲存到 `cover_image_url`
- 同時設定 `date` 欄位（向後兼容）和 `start_date` 欄位

#### Story 2.2: 瀏覽活動列表
**身份**：所有用戶（包含未登入）  
**目的**：瀏覽平台上的活動以找到感興趣的活動  
**場景**：我想找一些有趣的活動參加

**驗收標準**：
- 可以查看所有公開活動的列表
- 顯示活動標題、封面圖、日期、地點、參與人數
- 可以依類別篩選（hiking, travel 等）
- 可以依日期範圍篩選
- 可以依地點搜尋
- 可以依難度等級篩選
- 支援分頁載入
- 點擊活動卡片可進入詳情頁

**整合驗證點**：
- 系統應呼叫 `GET /api/activities` 端點
- 支援 query 參數：category, start_date, end_date, location, difficulty
- 預設只返回 status=active 的活動
- 回應應包含創建者基本資訊（name, avatar_url）
- 前端應顯示「剩餘名額」計算（max_participants - 當前參與人數）

#### Story 2.3: 查看活動詳情
**身份**：所有用戶  
**目的**：查看活動的完整資訊以決定是否參加  
**場景**：我對某個活動感興趣，想了解更多細節

**驗收標準**：
- 顯示活動的完整描述、日期時間、地點、費用
- 顯示創建者資料（姓名、頭像、評價）
- 顯示當前參與者列表
- 顯示活動圖片集
- 顯示活動討論區
- 顯示「立即參加」或「申請參加」按鈕
- 如果已額滿顯示「候補」選項（未來功能）
- 顯示活動狀態（進行中/已結束/已取消）

**整合驗證點**：
- 系統應呼叫 `GET /api/activities/<activity_id>` 端點
- 查詢應使用 `joinedload()` 預載參與者和創建者資料（避免 N+1）
- 回應應包含：activity 資料、creator 資料、participants 列表
- 前端應根據 status 欄位顯示不同的互動按鈕

#### Story 2.4: 申請加入活動
**身份**：已登入用戶  
**目的**：申請參加感興趣的活動  
**場景**：我找到一個喜歡的活動，想要申請加入

**驗收標準**：
- 點擊「申請參加」按鈕發送申請
- 可以選擇是否附上申請訊息（未來功能）
- 申請成功後顯示「等待審核」狀態
- 不能重複申請同一個活動
- 自己創建的活動自動成為參與者
- 活動已額滿時不能申請

**整合驗證點**：
- 系統應呼叫 `POST /api/activities/<activity_id>/join` 端點
- 端點應使用 `@jwt_required()` 驗證身分
- 後端應檢查：用戶是否已是參與者、活動是否已額滿
- 創建 ActivityParticipant 記錄，預設 status=pending
- 創建者應收到通知（未來整合推播）

#### Story 2.5: 審核參與申請（創建者）
**身份**：活動創建者  
**目的**：審核用戶的參與申請並決定是否批准  
**場景**：有用戶申請加入我的活動，我想審核他們的資料

**驗收標準**：
- 可以查看所有待審核的申請
- 顯示申請者的個人資料（姓名、頭像、簡介、評價）
- 可以批准或拒絕申請
- 批准後申請者成為正式參與者
- 拒絕後申請者收到通知
- 活動額滿時自動停止接受新申請

**整合驗證點**：
- 系統應呼叫 `PUT /api/activities/<activity_id>/participants/<user_id>` 端點
- 端點應驗證當前用戶是活動創建者
- 請求 payload 包含：status (approved/rejected)
- 後端應更新 ActivityParticipant 的 status 欄位
- 批准時應檢查是否超過 max_participants

#### Story 2.6: 查看我的活動
**身份**：已登入用戶  
**目的**：查看我創建或參加的所有活動  
**場景**：我想查看我參與的所有活動

**驗收標準**：
- 可以切換「我創建的」和「我參加的」分頁
- 顯示活動狀態（進行中/已結束）
- 可以查看活動的參與者資訊
- 創建者可以看到待審核申請的數量
- 可以快速進入活動詳情頁

**整合驗證點**：
- 系統應呼叫 `GET /api/activities?type=created` 或 `?type=joined`
- `type=created` 應過濾 creator_id=當前用戶
- `type=joined` 應查詢 ActivityParticipant 表並過濾 user_id=當前用戶 且 status=approved
- 使用 `@jwt_required()` 取得當前用戶 ID

#### Story 2.7: 編輯活動資訊
**身份**：活動創建者  
**目的**：修改活動的詳細資訊  
**場景**：我的活動計劃有變動，需要更新活動資訊

**驗收標準**：
- 只有創建者可以編輯活動
- 可以修改標題、描述、日期、地點等資訊
- 可以更換封面圖和活動圖片
- 修改後所有參與者收到通知（未來功能）
- 已開始的活動不能修改關鍵資訊（日期、地點）
- 顯示修改歷史記錄（未來功能）

**整合驗證點**：
- 系統應呼叫 `PUT /api/activities/<activity_id>` 端點
- 端點應驗證當前用戶是 creator_id
- 後端應更新 Activity 記錄
- 若修改 start_date，應同步更新 date 欄位（向後兼容）

#### Story 2.8: 取消活動
**身份**：活動創建者  
**目的**：取消已發布的活動  
**場景**：因為特殊原因我需要取消這個活動

**驗收標準**：
- 只有創建者可以取消活動
- 取消前顯示確認對話框
- 需要填寫取消原因
- 取消後活動狀態變為 cancelled
- 所有參與者收到取消通知（未來功能）
- 已取消的活動仍可查看但不能申請加入
- 可以選擇刪除活動（軟刪除或硬刪除）

**整合驗證點**：
- 系統應呼叫 `PUT /api/activities/<activity_id>` 設定 status=cancelled
- 或呼叫 `DELETE /api/activities/<activity_id>` 刪除活動
- 端點應驗證當前用戶是 creator_id
- 刪除時應考慮關聯資料（參與者、討論、費用）

#### Story 2.9: 標記活動為已完成
**身份**：活動創建者  
**目的**：在活動結束後標記為已完成  
**場景**：活動已順利結束，我想標記為完成狀態

**驗收標準**：
- 只有創建者可以標記為已完成
- 活動結束後才能標記
- 標記後狀態變為 completed
- 完成後參與者可以撰寫評價
- 完成的活動不再顯示在「進行中」列表
- 可以查看活動統計報告（參與人數、評價等）

**整合驗證點**：
- 系統應呼叫 `PUT /api/activities/<activity_id>` 設定 status=completed
- 端點應驗證當前用戶是 creator_id
- 後端應檢查 end_date 是否已過
- 完成後應觸發評價系統（允許參與者評價）

---

## Epic 3: 旅伴媒合系統 (Travel Companion Matching)

### 用戶故事

#### Story 3.1: 發起媒合申請（基於活動）
**身份**：已登入用戶  
**目的**：向活動中的其他參與者發起旅伴媒合  
**場景**：我在某個活動中看到一位感興趣的用戶，想要與他/她建立旅伴關係

**驗收標準**：
- 可以在活動參與者列表中點擊「發起媒合」
- 可以撰寫媒合申請訊息（message 欄位）
- 申請發送後顯示「等待回應」狀態
- 不能向自己發起媒合
- 不能重複向同一用戶發起媒合
- 申請記錄關聯到 activity_id

**整合驗證點**：
- 系統應呼叫 `POST /api/matches` 端點
- 請求 payload 包含：requester_id（從 JWT 取得）, requested_id, activity_id, message
- 創建 Match 記錄，預設 status=pending, match_date=當前時間
- 被申請者應收到通知（未來整合推播）

#### Story 3.2: 發起直接媒合（不基於活動）
**身份**：已登入用戶  
**目的**：直接向其他用戶發起旅伴媒合  
**場景**：我在用戶列表中找到興趣相投的用戶，想直接邀請成為旅伴

**驗收標準**：
- 可以在用戶個人資料頁點擊「邀請成為旅伴」
- 可以撰寫邀請訊息
- activity_id 為 NULL（直接媒合）
- 申請發送後顯示「等待回應」狀態
- 系統應記錄申請時間

**整合驗證點**：
- 系統應呼叫 `POST /api/matches` 端點
- activity_id 欄位可以為 NULL
- 資料庫 schema 應允許 activity_id 為 NULL
- 媒合記錄的顯示應區分「基於活動」和「直接邀請」

#### Story 3.3: 回應媒合申請
**身份**：收到媒合申請的用戶  
**目的**：確認或拒絕他人的媒合申請  
**場景**：有用戶向我發起旅伴媒合，我想查看他的資料並決定是否接受

**驗收標準**：
- 可以查看媒合申請的詳細資訊（申請者資料、申請訊息）
- 可以點擊「確認」或「拒絕」
- 確認後媒合狀態變為 confirmed，並記錄 confirmed_date
- 拒絕時可以填寫拒絕原因（rejection_reason）
- 拒絕後狀態變為 rejected
- 確認後自動創建聊天室（基於 match_id）

**整合驗證點**：
- 系統應呼叫 `PUT /api/matches/<match_id>` 端點
- 請求 payload 包含：status (confirmed/rejected), rejection_reason（選填）
- 端點應驗證當前用戶是 requested_id
- 確認時應設定 confirmed_date=當前時間，status=confirmed
- 拒絕時應設定 status=rejected, rejection_reason
- 確認後應觸發聊天室創建邏輯

#### Story 3.4: 取消媒合申請
**身份**：媒合申請發起者  
**目的**：撤回尚未被回應的媒合申請  
**場景**：我改變主意了，想要取消之前發送的媒合申請

**驗收標準**：
- 只能取消 status=pending 的申請
- 點擊「取消申請」按鈕
- 顯示確認對話框
- 取消後狀態變為 cancelled，記錄 cancel_date
- 被申請者收到取消通知（未來功能）

**整合驗證點**：
- 系統應呼叫 `PUT /api/matches/<match_id>` 端點
- 端點應驗證當前用戶是 requester_id
- 後端應檢查 status=pending
- 更新 status=cancelled, cancel_date=當前時間

#### Story 3.5: 查看我的媒合記錄
**身份**：已登入用戶  
**目的**：查看所有我發起或收到的媒合申請  
**場景**：我想查看我的旅伴媒合情況

**驗收標準**：
- 可以切換「我發起的」和「收到的」分頁
- 顯示媒合狀態（等待中/已確認/已拒絕/已取消）
- 可以查看對方的個人資料
- 顯示申請時間和訊息
- 已確認的媒合顯示「開始聊天」按鈕
- 可以篩選不同狀態的媒合記錄

**整合驗證點**：
- 系統應呼叫 `GET /api/matches?type=sent` 或 `?type=received`
- `type=sent` 過濾 requester_id=當前用戶
- `type=received` 過濾 requested_id=當前用戶
- 回應應包含對方用戶資料（name, avatar_url）
- 使用 `joinedload()` 預載用戶資料

#### Story 3.6: 查看媒合統計
**身份**：已登入用戶  
**目的**：查看我的媒合成功率和歷史記錄  
**場景**：我想了解我的媒合表現

**驗收標準**：
- 顯示媒合總數、成功數、拒絕數
- 顯示媒合成功率
- 顯示最近成功媒合的旅伴
- 顯示基於活動的媒合 vs 直接媒合的比例
- 可以查看歷史媒合記錄

**整合驗證點**：
- 系統應呼叫 `GET /api/matches/stats` 端點
- 後端應統計當前用戶的 Match 記錄
- 計算：confirmed 數量 / 總申請數量 = 成功率
- 分別統計 activity_id IS NOT NULL 和 IS NULL 的記錄

---

## Epic 4: 即時聊天系統 (Real-time Chat System)

### 用戶故事

#### Story 4.1: 建立聊天室（媒合確認後）
**身份**：已確認媒合的用戶  
**目的**：在媒合確認後自動創建聊天室開始溝通  
**場景**：我與另一位用戶的媒合已確認，我想開始與他/她聊天

**驗收標準**：
- 媒合確認後自動創建聊天室（基於 match_id）
- 聊天室對媒合的雙方可見
- 聊天室顯示對方的姓名和頭像
- 顯示「開始對話」提示訊息
- 聊天室列表按最後訊息時間排序

**整合驗證點**：
- 媒合確認時（Match status 變為 confirmed）應自動觸發聊天室創建
- 聊天室以 match_id 作為唯一識別
- 前端聊天列表應呼叫 `GET /api/chat/conversations` 端點
- 回應應包含：match_id, 對方用戶資料, 最後訊息, 未讀數量

#### Story 4.2: 建立 WebSocket 連線
**身份**：已登入用戶  
**目的**：建立 Socket.IO 連線以接收即時訊息  
**場景**：我開啟聊天功能，系統應自動連線到 WebSocket 伺服器

**驗收標準**：
- 進入聊天頁面時自動建立 WebSocket 連線
- 連線時傳遞 JWT token 進行身分驗證
- 連線成功後顯示線上狀態
- 連線失敗時顯示錯誤訊息並重試
- 離開頁面時自動斷開連線
- 網路斷線時自動重連

**整合驗證點**：
- 前端應使用 Socket.IO Client 連線到後端
- 連線 URL: `ws://backend:5000`（開發環境）
- 連線時應在 `auth.token` 參數中傳遞 JWT access token
- 後端 Socket.IO 的 `connect` 事件應驗證 token
- 驗證失敗應 disconnect 並返回錯誤
- 連線成功後後端應將 user_id 加入 online_users 字典

#### Story 4.3: 加入聊天室
**身份**：已登入用戶  
**目的**：加入特定的聊天室以收發訊息  
**場景**：我點擊某個聊天對象，進入聊天室

**驗收標準**：
- 點擊聊天對象後加入對應的聊天室（room = match_id）
- 自動載入歷史訊息（最近 50 條）
- 顯示對方的線上/離線狀態
- 可以看到對方正在輸入的提示（未來功能）
- 離開聊天室時自動退出 room

**整合驗證點**：
- 前端應發送 `join_room` Socket.IO 事件
- Payload: `{match_id: <match_id>}`
- 後端應驗證用戶是否為該 match 的參與者（requester 或 requested）
- 驗證通過後使用 `join_room(str(match_id))` 加入房間
- 發送 `room_joined` 事件確認
- 查詢歷史訊息：`GET /api/chat/messages?match_id=<match_id>&limit=50`

#### Story 4.4: 發送即時訊息
**身份**：已加入聊天室的用戶  
**目的**：發送文字訊息給聊天對象  
**場景**：我想傳訊息給旅伴

**驗收標準**：
- 可以輸入文字訊息並發送
- 訊息即時顯示在聊天視窗
- 訊息同時儲存到資料庫
- 顯示訊息發送時間
- 顯示訊息發送狀態（發送中/已送達/已讀）
- 支援多行文字輸入
- 空白訊息不能發送

**整合驗證點**：
- 前端發送 `send_message` Socket.IO 事件
- Payload: `{match_id: <match_id>, content: <message_text>}`
- 後端應創建 ChatMessage 記錄並儲存到資料庫
- 使用 `emit()` 將訊息廣播到該 room 的所有用戶
- 發送 `new_message` 事件，包含完整訊息資料（id, sender_id, content, timestamp）
- 前端接收 `new_message` 事件並顯示訊息

#### Story 4.5: 接收即時訊息
**身份**：已加入聊天室的用戶  
**目的**：即時接收對方發送的訊息  
**場景**：對方發送訊息給我，我應該即時收到

**驗收標準**：
- 對方發送訊息時即時顯示在聊天視窗
- 新訊息自動滾動到最底部
- 未讀訊息顯示紅點或數字提示
- 收到訊息時播放提示音（可選）
- 不在聊天室時顯示桌面通知（未來功能）
- 訊息按時間順序排列

**整合驗證點**：
- 前端監聽 `new_message` Socket.IO 事件
- 收到事件後將訊息加入聊天視窗
- 若用戶不在該聊天室，增加未讀數量
- 若用戶在該聊天室，自動標記為已讀（呼叫 `PUT /api/chat/messages/<message_id>/read`）

#### Story 4.6: 查看聊天歷史記錄
**身份**：已登入用戶  
**目的**：查看與某位旅伴的歷史聊天記錄  
**場景**：我想回顧之前與旅伴的對話內容

**驗收標準**：
- 可以滾動載入更早的訊息（無限滾動）
- 顯示訊息的發送時間
- 顯示訊息的已讀/未讀狀態
- 可以搜尋歷史訊息（未來功能）
- 支援訊息分頁載入（每次 50 條）
- 可以查看訊息的完整時間戳

**整合驗證點**：
- 系統應呼叫 `GET /api/chat/messages` 端點
- Query 參數：match_id, limit=50, offset=0
- 後端應查詢 ChatMessage 表，過濾 match_id
- 使用 `order_by(ChatMessage.created_at.desc())` 按時間倒序
- 回應應包含：訊息列表、總數、是否還有更多
- 前端實作無限滾動，觸底時增加 offset 載入更多

---

## Epic 5: 費用管理與分帳系統 (Expense Management)

### 用戶故事

#### Story 5.1: 建立活動費用記錄
**身份**：活動參與者  
**目的**：記錄活動相關費用並選擇分帳方式  
**場景**：我參加了一個活動並支付了部分費用，我想記錄這筆支出並與其他參與者分帳

**驗收標準**：
- 可以選擇所屬活動（從參與的活動清單中選擇）
- 可以輸入費用描述、金額、幣別
- 可以選擇分帳類型（平均分攤 / 按比例 / 個別金額）
- 可以選擇分帳對象（活動參與者子集）
- 系統自動記錄建立者為支付者
- 建立成功後返回費用詳情

**整合驗證點**：
- 費用記錄必須關聯到現有 Activity 記錄
- 分帳對象必須是活動的有效參與者
- 系統應呼叫 `POST /api/expenses` 端點並傳遞費用資料
- 資料應儲存到 `expenses` 表格，包含 activity_id, payer_id, description, amount, currency, split_type

#### Story 5.2: 查看活動費用清單
**身份**：活動參與者  
**目的**：查看某個活動的所有費用記錄  
**場景**：我想檢視我參加的活動總共有哪些費用支出

**驗收標準**：
- 可以查看指定活動的所有費用記錄
- 費用清單顯示支付者、描述、金額、幣別、分帳類型
- 可以看到每筆費用的應分帳人員
- 顯示費用建立時間

**整合驗證點**：
- 系統應呼叫 `GET /api/expenses/activity/<activity_id>` 端點
- 查詢應包含支付者（User）和分帳人員資訊
- 前端應正確顯示不同分帳類型（equal, percentage, exact）

#### Story 5.3: 查看個人費用統計
**身份**：用戶  
**目的**：查看我在所有活動中的費用支付和欠款情況  
**場景**：我想知道我總共支付了多少費用，以及還欠其他人多少錢

**驗收標準**：
- 顯示我作為支付者的所有費用總額
- 顯示我需要分攤的費用總額
- 顯示淨支出（支付總額 - 應分攤總額）
- 可以依活動分組查看
- 可以依時間範圍篩選

**整合驗證點**：
- 系統應呼叫 `GET /api/expenses/user/<user_id>` 端點
- 後端應計算用戶作為 payer 的費用總和
- 後端應計算用戶在 split_with 清單中的費用分攤總和

#### Story 5.4: 修改費用記錄
**身份**：費用建立者  
**目的**：修正已建立的費用記錄資訊  
**場景**：我發現之前記錄的費用金額有誤，需要更新

**驗收標準**：
- 只有費用建立者可以編輯該費用
- 可以修改描述、金額、分帳類型、分帳對象
- 修改後所有分帳人員應收到通知（未來）
- 修改歷史應被記錄（未來）

**整合驗證點**：
- 系統應呼叫 `PUT /api/expenses/<expense_id>` 端點
- 後端應驗證當前用戶是否為費用的 payer_id
- 更新應包含 JWT 認證的 `@jwt_required()` 檢查

#### Story 5.5: 刪除費用記錄
**身份**：費用建立者  
**目的**：刪除錯誤或重複的費用記錄  
**場景**：我不小心重複建立了費用記錄，需要刪除

**驗收標準**：
- 只有費用建立者可以刪除該費用
- 刪除前應顯示確認對話框
- 刪除後應從清單中移除
- 已刪除的費用不應影響統計數據

**整合驗證點**：
- 系統應呼叫 `DELETE /api/expenses/<expense_id>` 端點
- 後端應驗證當前用戶是否為費用的 payer_id
- 應使用軟刪除或硬刪除策略（視業務需求）

#### Story 5.6: 費用幣別支援
**身份**：國際旅行者  
**目的**：以不同幣別記錄費用  
**場景**：我在不同國家旅行，需要以當地幣別記錄費用

**驗收標準**：
- 可以選擇費用幣別（TWD, USD, EUR, JPY 等）
- 系統應顯示幣別符號
- 統計數據應依幣別分組
- 未來可考慮匯率轉換功能

**整合驗證點**：
- Expense 模型的 `currency` 欄位應正確儲存
- 前端應提供幣別選擇器
- API 回應應包含 currency 資訊

---

## Epic 6: 社交互動與評價系統 (Social Interaction)

### 用戶故事

#### Story 6.1: 撰寫活動評價
**身份**：活動參與者  
**目的**：在活動結束後分享體驗和評價  
**場景**：我參加完一個活動，想分享我的體驗並給予評分

**驗收標準**：
- 只有已參與的活動可以評價
- 可以給予 1-5 星評分
- 可以撰寫文字評論（選填）
- 可以選擇評價類型（整體 / 組織者 / 地點）
- 可以匿名或公開評價
- 提交後即時顯示在活動詳情頁

**整合驗證點**：
- 系統應呼叫 `POST /api/reviews` 端點
- 後端應驗證用戶是否為活動參與者（檢查 activity_participants）
- 資料應儲存到 `activity_reviews` 表格

#### Story 6.2: 查看活動評價列表
**身份**：所有用戶  
**目的**：查看其他人對活動的評價以決定是否參加  
**場景**：我考慮參加一個活動，想先看看其他人的評價

**驗收標準**：
- 可以查看活動的所有評價
- 顯示評價者姓名（或匿名）、評分、評論內容、時間
- 可以看到活動的平均評分
- 可以依評分高低或時間排序
- 顯示評價總數

**整合驗證點**：
- 系統應呼叫 `GET /api/reviews/activity/<activity_id>` 端點
- 查詢應包含評價者（User）資訊
- 前端應計算並顯示平均評分

#### Story 6.3: 活動討論區參與
**身份**：活動參與者或感興趣的用戶  
**目的**：在活動討論區提問或分享資訊  
**場景**：我對活動的某些細節有疑問，想在討論區詢問

**驗收標準**：
- 可以發表新討論主題
- 可以回覆其他人的討論
- 討論內容應即時更新
- 可以看到討論發表時間和作者
- 活動建立者的回覆應有特殊標示

**整合驗證點**：
- 系統應呼叫 `POST /api/discussions` 端點
- 資料應儲存到 `activity_discussions` 表格
- 查詢應使用 `GET /api/discussions/activity/<activity_id>` 端點

#### Story 6.4: 修改或刪除自己的評價
**身份**：評價撰寫者  
**目的**：修正或移除我之前的評價  
**場景**：我想修改之前的評價內容或評分

**驗收標準**：
- 只能修改或刪除自己的評價
- 修改評價後應更新平均評分
- 刪除評價需要確認
- 修改歷史應被記錄（未來功能）

**整合驗證點**：
- 系統應呼叫 `PUT /api/reviews/<review_id>` 或 `DELETE /api/reviews/<review_id>` 端點
- 後端應驗證當前用戶是否為評價的 user_id

---

## Epic 7: 檔案上傳與管理 (File Upload)

### 用戶故事

#### Story 7.1: 上傳用戶頭像
**身份**：註冊用戶  
**目的**：上傳個人頭像以建立個人形象  
**場景**：我想上傳一張照片作為我的個人頭像

**驗收標準**：
- 可以選擇圖片檔案上傳（支援 JPG, PNG, GIF）
- 檔案大小限制在 5MB 以內
- 系統應自動壓縮並產生縮圖
- 上傳成功後頭像即時更新
- 舊頭像應被刪除或覆蓋

**整合驗證點**：
- 系統應呼叫 `POST /api/upload` 端點並指定 upload_type=avatar
- 後端應驗證檔案類型和大小
- 檔案應儲存到 `backend/uploads/avatars/` 目錄
- User 模型的 `avatar_url` 欄位應更新

#### Story 7.2: 上傳活動圖片
**身份**：活動建立者  
**目的**：上傳活動宣傳圖片吸引參與者  
**場景**：我建立了一個活動，想上傳一張圖片讓活動更吸引人

**驗收標準**：
- 可以在建立或編輯活動時上傳圖片
- 支援 JPG, PNG 格式
- 檔案大小限制在 10MB 以內
- 圖片應顯示在活動詳情頁
- 每個活動可以上傳多張圖片（未來功能）

**整合驗證點**：
- 系統應呼叫 `POST /api/upload` 端點並指定 upload_type=activity
- 檔案應儲存到 `backend/uploads/activities/` 目錄
- Activity 模型的 `image_url` 欄位應更新

#### Story 7.3: 查看和刪除已上傳檔案
**身份**：檔案上傳者  
**目的**：管理我上傳的檔案  
**場景**：我想查看或刪除之前上傳的檔案

**驗收標準**：
- 可以查看我上傳的所有檔案清單
- 可以刪除自己上傳的檔案
- 刪除檔案前應顯示確認對話框
- 刪除後相關引用應更新為預設圖片

**整合驗證點**：
- 系統應提供 `GET /api/uploads/user/<user_id>` 端點查詢檔案
- 刪除應呼叫 `DELETE /api/uploads/<file_id>` 端點
- 後端應同時刪除檔案系統中的實體檔案

---